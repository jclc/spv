package main

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"math/rand"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

const (
	genComment = "// Code generated by github.com/jclc/spv. DO NOT EDIT."
)

type generatedFile struct {
	Package string
}

func makeSliceIdentifier(s string) string {
	return "spv_" + makeIdentifier(s)
}

func operate(f string, statusChan chan string) (bool, error) {
	inFileName := filepath.Join(dir, f)
	inStat, err := os.Stat(inFileName)
	if err != nil {
		return false, err
	}

	outFileName := generatedName(inFileName)
	outStat, err := os.Stat(outFileName)
	if err != nil && !os.IsNotExist(err) {
		return false, err
	}
	if err == nil && outStat.ModTime().After(inStat.ModTime()) && !force {
		if verbose {
			statusChan <- fmt.Sprintf("%s is unmodified; skipping", f)
		}
		return false, nil
	}

	spvFile := filepath.Join(tempDir, fmt.Sprintf("%s_%d.spv", f, rand.Int()))

	var args []string
	args = append(args, strings.Split(ccArgs, " ")...)
	args = append(args, "-o", spvFile, inFileName)
	cmd := exec.Command(cc, args...)

	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	err = cmd.Run()
	if err != nil {
		if stdout.Len() > 0 {
			return false, errors.New("\n" + stdout.String())
		} else if stderr.Len() > 0 {
			return false, errors.New("\n" + stderr.String())
		}
		return false, err
	}

	if verbose && stdout.Len() > 0 {
		statusChan <- fmt.Sprintf("-- %s --\n%s", f, stdout.String())
	}

	err = writeGoFile(inFileName, spvFile, outFileName)
	if err != nil {
		return false, err
	}

	return true, nil
}

func writeGoFile(source, in, out string) error {
	inFile, err := os.Open(in)
	if err != nil {
		return err
	}
	defer inFile.Close()

	outFile, err := os.Create(out)
	if err != nil {
		return err
	}
	defer outFile.Close()

	// cleanedSrc := strings.ReplaceAll(filepath.Base(source), ".", "_")
	varName := makeSliceIdentifier(source)
	// pathConst := "SpvPath_" + cleanedSrc

	outFile.WriteString(genComment)
	fmt.Fprintf(outFile, "\n\npackage %s\n\n", pkg)
	// fmt.Fprintf(outFile, "const %s = \"%s\"\n\n", pathConst, source)
	fmt.Fprintf(outFile, "var %s = []uint32{\n\t", varName)

	inBuf := bufio.NewReader(inFile)
	h := hex.NewEncoder(outFile)
	outEndianness := binary.BigEndian // Endianness in the resulting Go file
	var inEndianness binary.ByteOrder // Endianness in the compiled SPIR-V file

	var bb [4]byte
	var ui uint32
	inBuf.Read(bb[:])
	if bb == [4]byte{0x07, 0x23, 0x02, 0x03} {
		inEndianness = binary.BigEndian
	} else if bb == [4]byte{0x03, 0x02, 0x23, 0x07} {
		inEndianness = binary.LittleEndian
	} else {
		return fmt.Errorf("invalid magic number %x", bb)
	}

	for {
		outFile.WriteString("0x")
		ui = inEndianness.Uint32(bb[:])
		binary.Write(h, outEndianness, ui)
		outFile.WriteString(", ")

		_, err := inBuf.Read(bb[:])
		if err != nil {
			break
		}
	}

	outFile.WriteString("\n}\n")

	return nil
}
